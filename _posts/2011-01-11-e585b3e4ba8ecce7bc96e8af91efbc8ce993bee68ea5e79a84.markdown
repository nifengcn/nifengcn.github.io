---
author: nifeng
comments: true
date: 2011-01-11 11:57:38+00:00
layout: post
slug: '%e5%85%b3%e4%ba%8ecc%e7%bc%96%e8%af%91%ef%bc%8c%e9%93%be%e6%8e%a5%e7%9a%84'
title: C/C++的符号冲突
wordpress_id: 74
categories: tech
tags: [c, c++, vc, gcc]
---
这篇文章参考了CSDN上的一篇博文，该博文也是转载的，但未给出引用的链接，而原作者是谁懒得去找了，附上[链接][csdn]。



#### 库和可执行文件 ####

c/c++源程序主要经过两个步骤生成可执行文件：
>1. 通过编译器将源程序编译成目标文件（.obj为后缀的文件）；
>2. 通过链接器将这些目标文件以及用到的一些函数库（.lib为后缀的文件）链接成一个可执行文件。

需要说明的是，通常在编译时，只要函数和变量的声明就可以通过通过编译，而在链接的过程中确定函数和变量的定义，这一过程称为解析(resolve)。
这一点对于使用了动态链接库(.dll后缀名)的程序来说不适用的，在使用了动态链接库的程序中，
在链接的过程中只需要要其动态链接库的导入库(.lib文件)即可，只有在程序真正运行的时候才需要动态链接库，
而实际上函数的定义是在动态链接库中的，这应该就是“动态”的意义所在吧。

以.lib为后缀的文件可心是静态链接库，也可以是动态链接库的导入库，这两种文件的性质是完全不同的：
>1. 静态链接库实际上是由多个目标文件打包而成的一个文件，在链接时链接器会把（且只把）使用到的目标模块从库中拷贝出来参与构造可执行文件，
>在发布产品的时候，只要发布可执行文件即可，而不需要发布所使用到的静态链接库；
>2. 动态库只包含其对应DLL导出的变量和函数的符号名，而实际上的数据和函数在.dll文件中，
>在编译链接时只需要引入库文件，.dll中的数据和函数并不复制到可执行文件中去，直到可执行文件运行时才去加载所需的DLL，
>将DLL映射到进程的地址空间中，然后访问其导出的函数，在发布产品的时候，可执行文件和使用到的动态链接库需要一起发布。



#### 符号冲突 ####

关于链接我们再做一些探讨：
链接的过程其实就是对不同目标模块中定义的函数和全局变量相互引用的解析，函数和全局变量都称为“符号（Symbol）”，
因此链接的过程必须要对符号进行完善的管理。关于如何管理，大家可以参考这个[链接][symbol]。
我们这边对于如何管理不做深入探讨，我们关注“符号”冲突。

首先我们关注下C++中函数重载的概念，由于同一个函数就代表了好几个不同的函数，那么在进行解析的时候，
我们如何知道调用的到底是哪一个函数呢？ 在C＋＋中为此引入了“函数签名”的概念，
每个函数签名包含这一个函数的返回类型、参数类型、函数名、所在名字空间、所在类等所有的信息，然后编译器和链接器在处理一个符号的时候，
按照某种“符号名称修饰”法则使得每一个函数签名对应着一个修饰后的符号名。对于全局变量和静态变量同样采用类似的签名机制 。
在VC++中可以使用dumpbin命令看出函数名称发生了变化，而产生变化的原因正是因为引入了“函数签名”的概念。
用符号名修饰机制使得编译器和链接器就可以分清楚各个模块中定义的每一个符号而不至产生符号名冲突了，
但是由此另外一个问题则是，不同编译器采用不同的符号修饰法则，故而不同编译器编译出来的目标文件往往无法正常链接到一起。
为了解决C和C++编译器因为符号修饰方法不同导致的使用C和C++编写的模块之间不能正确链接的问题，C++中通过 `extern "C"{ }` 机制来实现兼容。
即包括在大括号内部的代码将被C++编译器当作纯粹的C语言代码来编译，这样C++的符号修饰方法就不会用在这段代码上。

现在我们再次回到我们原来的通常主题“符号”冲突（好像有点绕哈。）。
有时候我们希望可以在不同的模块中存在相同的函数定义（完全相同，而不是重载），这就引入了强符号和弱符号的概念:
>系统中某些扩展功能模块可能时有时无，如果要求系统在两种情况下都能正常工作，
>这就需要在功能模块不存在时主程序中对这些扩展功能模块的引用不能报错——这就是“强引用”和“弱引用”的概念。

对于强符号和弱符号有如下的规则：
>1. 链接器工作时，不允许各个模块中出现同名的强符号，
>2. 当仅有一个模块中为强符号其他模块中为弱符号时，链接器选择强符号；
>3. 如果只存在多个弱符号链接器选择占用空间最大的那个——这种情况必须避免，否则错误难以发现。

对于C/C++编译器，在本目标文件中定义的函数和初始化了的全局变量为强符号，本目标文件中定义的未初始化全局变量为弱符号，
而在本目标文件中使用extern引用的符号不属于强弱符号定义的范畴。
弱符号往往使用在库中，GCC下可以通过__attribute__((weak))关键字显式地定义一个弱符号。
默认地，本模块中所有对外部符号的引用在链接时都是强引用，该符号必须能够被正确决议（理解为“绑定”的同义词），否则链接器就会报错；
GCC中可以通过__attribute__ ((weakref))关键字显式地将对一个外部符号的应用定义为弱引用，这样即使在链接的时候该符号并没有正确地找到定义，
链接器也不会报错，而只是将该符号的符号值（st_value）置为0，但是这样得到的可执行程序在执行时会出错，因为当调用弱符号时，弱符号地址为0，
属于非法访问。因此在程序中调用一个外部符号时，应该先判断其值是否为0，若不为0再进行调用。
在GCC下使用 gcc -g 参数会在目标文件中加入大量的debug相关的段，调试信息在目标文件/可执行文件中占据了不少的空间，
当程序最终发布的时候应该将调试信息从中去除以节省大量空间。Linux下可以使用strip 文件名命令来去除ELF文件中的调试信息。

接着我们看看链接器是如何解析对程序库（静态库）的引用的。在符号解析(symbol resolution)阶段，
链接器按照所有目标文件和库文件出现在命令行中的顺序从左至右依次扫描它们，在此期间它要维护若干个集合:
>集合E是将被合并到一起组成可执行文件的所有目标文件集合；
>
>集合U是未解析符号(unresolved symbols，比如已经被引用但是还未被定义的符号)的集合；
>
>集合D是所有之前已被加入到E的目标文件定义的符号集合。

一开始，E、U、D都是空的。
>1. 对命令行中的每一个输入文件f，链接器确定它是目标文件还是库文件，如果它是目标文件，就把f加入到E，
>   并把f中未解析的符号和已定义的符号分别加入到U、D集合中，然后处理下一个输入文件。
>   如果f是一个库文件，
>2. 链接器会尝试把U中的所有未解析符号与f中各目标模块定义的符号进行匹配。如果某个目标模块m定义了一个U中的未解析符号，
>   那么就把该解析符号从U转移到D，将m加入到E中，并把m中未解析的符号和已定义的符号分别加入到U、D集合中。
>   不断地对f中的所有目标模块重复这个过程直至到达一个不动点(fixed point)， 此时U和D不再变化。
>   而那些未加入到E中的f里的目标模块就被简单地丢弃，链接器继续处理下一输入文件。
>3. 如果处理过程中往D加入一个已存在的符号，或者当扫描完所有输入文件时U非空，链接器报错并停止动作。
>   否则，它把E中的所有目标文件合并在一起生成可执行文件。

VC带的编译器名字叫cl.exe，它有这么几个与标准程序库有关的选项:` /ML、/MLd、/MT、/MTd、/MD、/MDd`。

这些选项告诉编译器应用程序想使用什么版本的C标准程序库。
>/ML(缺省选项)对应单线程静态版的标准程序库(libc.lib)（vs08中默认的缺省项应该是改成了LIBCMT.LIB）；
>
>/MT对应多线程静态版标准库(libcmt.lib)，此时编译器会自动定义_MT宏；
>
>/MD对应多线程DLL版(导入库msvcrt.lib，DLL是msvcrt.dll)，编译器自动定义_MT和_DLL两个宏。

后面加d的选项都会让编译器自动多定义一个_DEBUG宏，表示要使用对应标准库的调试版，因此
>/MLd对应调试版单线程静态标准(libcd.lib)，
>
>/MTd对应调试版多线程静态标准库(libcmtd.lib)，
>
>/MDd对应调试版多线程DLL标准库(导入库msvcrtd.lib，DLL是msvcrtd.dll)。

虽然我们的确在编译时明白无误地告诉了编译器应用程序希望使用什么版本的标准库，可是当编译器干完了活，
轮到链接器开工时它又如何得知一个个目标文件到底在思念谁？为了传递相思，我们的编译器就干了点秘密的勾当。
在cl编译出的目标文件中会有一个专门的区域(关心这个区域到底在文件中什么地方的朋友可以参考COFF和PE文件格式)
存放一些指导链接器如何工作的信息，其中有一种就叫缺省库(default library)，这些信息指定了一个或多个库文件名，
告诉链接器在扫描的时候也把它们加入到输入文件列表中(当然顺序位于在命令行中被指定的输入文件之后)。
说到这里，我们先来做个小实验。写个顶顶简单的程序，然后保存为main.c :

{% highlight c++ %}
/* main.c */
int main() { return 0; }
{% endhighlight %}

用下面这个命令编译main.c(什么？你从不用命令行来编译程序？这个......) :

{% highlight c++ %}
cl /c main.c
{% endhighlight %}

/c是告诉cl只编译源文件，不用链接。因为/ML是缺省选项，所以上述命令也相当于: cl /c /ML main.c (vs08应该是/MT)。
如果没什么问题的话(要出了问题才是活见鬼！当然除非你的环境变量没有设置好，这时你应该去VC的bin目录下找到vcvars32.bat文件然后运行它。)，
当前目录下会出现一个main.obj文件，这就是我们可爱的目标文件。随便用一个文本编辑器打开它(是的，文本编辑器，大胆地去做别害怕)，
搜索"defaultlib"字符串，通常你就会看到这样的东西: `-defaultlib:LIBC -defaultlib:OLDNAMES`。
（vs08中看到是 /DEFAULTLIB :"LIBCMT"  /DEFAULTLIB:"OLDNAMES"）啊哈，没错，这就是保存在目标文件中的缺省库信息。
我们的目标文件显然指定了两个缺省库，一个是单线程静态版标准库libc.lib(这与/ML选项相符)，
另外一个是oldnames.lib(它是为了兼容微软以前的C/C++开发系统)。

VC的链接器是link.exe,使用link命令时会提示缺少需要设置一下环境变量，主要设置3个环境变量，分别为path,incluDe和lib。

>PATH=C:\Program Files\Microsoft Visual Studio 9.0\VC\bin
>INCLUDE=C:\Program Files\Microsoft Visual Studio 9.0\VC\include
>LIB=C:\Program Files\Microsoft Visual Studio 9.0\VC\lib;C:\Program Files\Microsoft SDKs\Windows\v6.0A\Lib）

`link main.obj libc.lib`或者`link main.obj`来生成可执行文件main.exe，这两个命令是等价的。
但是如果你用`link main.obj libcd.lib`的话，链接器会给出一个警告:

>"warning LNK4098: defaultlib "LIBC" conflicts with use of other libs; use /NODEFAULTLIB:library"，

因为你显式指定的标准库版本与目标文件的缺省值不一致。通常来说，应该保证链接器合并的所有目标文件指定的缺省标准库版本一致，
否则编译器一定会给出上面的警告，而LNK2005和LNK1169链接错误则有时会出现有时不会。那么这个有时到底是什么时候？
呵呵，别着急，下面的一切正是为喜欢追根究底的你准备的。建一个源文件，就叫mylib.c，内容如下:

{% highlight c++ %}
/* mylib.c */
#include <stdio.h>
void foo()
{
    printf("%s","I am from mylib!\n");
}
{% endhighlight %}

用`cl /c /MLd mylib.c`命令编译，注意/MLd选项是指定libcd.lib为默认标准库。
lib.exe是VC自带的用于将目标文件打包成程序库的命令，所以我们可以用`lib /OUT:my.lib mylib.obj`
将mylib.obj打包成库，输出的库文件名是my.lib。接下来把main.c改成:

{% highlight c++ %}
/* main.c */
void foo();
int main()
{
    foo();
    return 0;
}
{% endhighlight %}

用`cl /c main.c`编译，然后用`link main.obj my.lib`进行链接。
这个命令能够成功地生成main.exe而不会产生LNK2005和LNK1169链接错误，你仅仅是得到了一条警告信息:

>"warning LNK4098: defaultlib "LIBCD" conflicts with use of other libs; use /NODEFAULTLIB:library"。

我们根据前文所述的扫描规则来分析一下链接器此时做了些啥:一开始E、U、D都是空集，链接器首先扫描到main.obj，把它加入E集合，
同时把未解析的foo加入U，把main加入D，而且因为main.obj的默认标准库是libc.lib，所以它被加入到当前输入文件列表的末尾。
接着扫描my.lib，因为这是个库，所以会拿当前U中的所有符号(当然现在就一个foo)与my.lib中的所有目标模块(当然也只有一个mylib.obj)依次匹配，
看是否有模块定义了U中的符号。结果mylib.obj确实定义了foo，于是它被加入到E，foo从U转移到D，mylib.obj引用的printf加入到U，同样地，
mylib.obj指定的默认标准库是libcd.lib，它也被加到当前输入文件列表的末尾(在libc.lib的后面)。
不断地在my.lib库的各模块上进行迭代以匹配U中的符号，直到U、D都不再变化。很明显，现在就已经到达了这么一个不动点，
所以接着扫描下一个输入文件，就是libc.lib。链接器发现libc.lib里的printf.obj里定义有printf，于是printf从U移到D，而printf.obj被加入到E，
它定义的所有符号加入到D，它里头的未解析符号加入到U。
链接器还会把每个程序都要用到的一些初始化操作所在的目标模块(比如crt0.obj等)及它们所引用的模块(比如malloc.obj、free.obj等)自动加入到E中，
并更新U和D以反应这个变化。事实上，标准库各目标模块里的未解析符号都可以在库内其它模块中找到定义，因此当链接器处理完libc.lib时，
U一定是空的。最后处理libcd.lib，因为此时U已经为空，所以链接器会抛弃它里面的所有目标模块从而结束扫描，
然后合并E中的目标模块并输出可执行文件。

上文描述了虽然各目标模块指定了不同版本的缺省标准库但仍然链接成功的例子，接下来你将目睹因为这种不严谨而导致的悲惨失败。
修改mylib.c成这个样子:

{% highlight c++ %}
#include
void foo()
{
// just a test , don't care memory leak
    _malloc_dbg( 1, _NORMAL_BLOCK, __FILE__, __LINE__ );
}
{% endhighlight %}

其中`_malloc_dbg`不是ANSI C的标准库函数，它是VC标准库提供的malloc的调试版，与相关函数配套能帮助开发者抓各种内存错误。
使用它一定要定义_DEBUG宏，否则预处理器会把它自动转为malloc。继续用`cl /c /MLd mylib.c lib /OUT:my.lib mylib.oBj`编译打包。
当再次用`link main.obj my.lib`进行链接时，我们看到了什么？
天哪，一堆的LNK2005加上个贵为"fatal error"的LNK1169垫底，当然还少不了那个LNK4098。
链接器是不是疯了？不，你冤枉可怜的链接器了，我拍胸脯保证它可是一直在尽心尽责地照章办事。
一开始E、U、D为空，链接器扫描main.obj，把它加入E，把foo加入U，把main加入D，把libc.lib加入到当前输入文件列表的末尾。
接着扫描my.lib，foo从U转移到D，_malloc_dbg加入到U，libcd.lib加到当前输入文件列表的尾部。
然后扫描libc.lib，这时会发现libc.lib里任何一个目标模块都没有定义_malloc_dbg(它只在调试版的标准库中存在)，
所以不会有任何一个模块因为_malloc_dbg而加入E，但是每个程序都要用到的初始化模块(如crt0.obj等)
及它们所引用的模块(比如malloc.obj、free.obj等)还是会自动加入到E中，同时U和D被更新以反应这个变化。
当链接器处理完libc.lib时，U只剩_malloc_dbg这一个符号。最后处理libcd.lib，发现dbgheap.obj定义了_malloc_dbg，
于是dbgheap.obj加入到E，它里头的未解析符号加入U，它定义的所有其它符号也加入D，这时灾难便来了。
之前malloc等符号已经在D中(随着libc.lib里的malloc.obj加入E而加入的)，而dbgheap.obj又定义了包括malloc在内的许多同名符号，
这引发了重定义冲突，链接器只好中断工作并报告错误。

在我们该知道，链接器完全没有责任，责任在我们自己的身上。
是我们粗心地把缺省标准库版本不一致的目标文件(main.obj)与程序库(my.lib)链接起来，导致了大灾难。
解决办法很简单，要么用/MLd选项来重编译main.c；要么用/ML选项重编译mylib.c。
在上述例子中，我们拥有库my.lib的源代码(mylib.c)，所以可以用不同的选项重新编译这些源代码并再次打包。
可如果使用的是第三方的库，它并没有提供源代码，那么我们就只有改变自己程序的编译选项来适应这些库了。
但是如何知道库中目标模块指定的默认库呢？其实VC提供的一个小工具便可以完成任务，这就是dumPBin.exe。
运行下面这个命令`dumpbin /DIRECTIVES my.lib`,然后在输出中找那些"Linker Directives"引导的信息，
你一定会发现每一处这样的信息都会包含若干个类似"-defaultlib:XXXX"这样的字符串，
其中XXXX便代表目标模块指定的缺省库名。知道了第三方库指定的默认标准库，再用合适的选项编译我们的应用程序，
就可以避免LNK2005和LNK1169链接错误。



[csdn]:<http://blog.csdn.net/anthit/archive/2009/01/03/3694919.aspx>
[symbol]:<http://www.cnblogs.com/tryknowwhy/archive/2009/12/09/1619575.html>
