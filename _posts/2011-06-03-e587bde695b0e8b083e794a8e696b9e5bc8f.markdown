---
author: nifeng
comments: true
date: 2011-06-03 15:34:10+00:00
layout: post
slug: '%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e6%96%b9%e5%bc%8f'
title: 函数调用方式
wordpress_id: 150
categories:
- tech
tags:
- vc
- c++
- c
---

##堆栈##

编译器一般使用堆栈实现函数调用。堆栈是存储器的一个区域，嵌入式环境有时需要程序员自己定义一个数组作为堆栈。
Windows为每个线程自动维护一个堆栈，堆栈的大小可以设置。编译器使用堆栈来堆放每个函数的参数、局部变量等信息。

函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息，每个函数占用一个连续的区域。一个函数占用的区域被称作帧（frame）。

编译器从高地址开始使用堆栈。 假设我们定义一个数组a[1024]作为堆栈空间，一开始栈顶指针指向a[1023]。
如果栈里有两个函数a和b，且a调用了b，栈顶指针会指向函数b的 帧。如果函数b返回。栈顶指针就指向函数a的帧。
如果在栈里放了太多东西造成溢出，破坏的是a[0]上面的东西。 
在多线程（任务）环境，CPU的堆栈指针指向的存储器区域就是当前使用的堆栈。
切换线程的一个重要工作，就是将堆栈指针设为当前线程的堆栈栈顶地址。

不同CPU，不同编译器的堆栈布局、函数调用方法都可能不同，但堆栈的基本概念是一样的。

##函数调用约定##

函数调用约定包括传递参数的顺序，谁负责清理参数占用的堆栈等，例如 ：
 {% highlight c %}
||          || 参数传递顺序||谁负责清理参数占用的堆栈||
|| __pascal || 从左到右    ||调用者                  ||
|| __stdcall|| 从右到左    ||被调函数                ||
|| __cdecl  || 从右到左    ||调用者                  ||
 {% endhighlight %}

调用函数的代码和被调函数必须采用相同的函数的调用约定，程序才能正常运行。在Windows上，__cdecl是C/C++程序的缺省函数调用约定。

在有的cpu上，编译器会用寄存器传递参数，函数使用的堆栈由被调函数分配和释放。
这种调用约定在行为上和__cdecl有一个共同点：实参和形参数目不符不会导致堆栈错误。

不过，即使用寄存器传递参数，编译器在进入函数时，还是会将寄存器里的参数存入堆栈指定位置。
参数和局部变量一样应该在堆栈中有一席之地。参数可以被理解为由调用函数指定初值的局部变量。

##\_\_stdcall与\_\_cdecl的区别##

1.  默认支持：VC默认使用\_\_cdecl。所以如果需要使用_stdcall，可采用两种方法：

    *   可以在函数名前手工添加，只对单一函数有效 
    *   直接修改工程属性（C/C++ \> Advanced \> Calling Convention）来一次性配置所有的函数

2.  功能不同：\_\_cdecl可实现变长参数列表

3.  代码大小：\_\_stdcall更小

4.  速度不同：\_\_cdecl更快（代码更多当然意味着运行更快，有点像内联函数）

5.  谁负责恢复堆栈：\_\_cdecl主调用函数进行参数压栈并且恢复堆栈；\_\_stdcall主调用函数进行参数压栈，被调函数恢复堆栈；
    这也正是产生
    *   不同代码大小的原因：如果使用\_\_cdecl的函数多次调用同一函数，就要产生多份恢复码。
    *   功能不同的原因：实现变长参数列表。
        一份恢复码只能将一种长度的参数表出栈，所以要对不同长度的参数表堆栈恢复，必须要有多份代码，
        所以变长参数必须有主调函数恢复（所以是\_\_cdecl）。

6.  产生的函数名不同：

    \_\_stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，格式为\_functionname@number。
    \_\_cdecl调用约定仅在输出函数名前加上一个下划线前缀，格式为\_functionname。

7.  使用范围：
    \_\_stdcall：通常用于DLL的创建（以支持多语言调用）；此外Win32 API函数皆用\_\_stdcall（比如MessageBox），
    所以Win32程序中的自定义函数也做好使用_stdcall。

    \_\_cdecl：非DLL的console程序。

##跨语言调用##

函数调用约定只是“调用函数的代码”和被调用函数之间的关系。

假设函数A是__stdcall，函数B调用函数A。你必须通过函数声明告诉编译器，函数A是__stdcall。编译器自然会产生正确的调用代码。

如果函数A是__stdcall。但在引用函数A的地方，你却告诉编译器，函数A是__cdecl方式，编译器产生__cdecl方式的代码，
与函数A的调用约定不一致，就会发生错误。

以delphi调用VC函数为例，delphi的函数缺省采用__pascal约定，VC的函数缺省采用__cdecl约定。我们一般将VC的函数设为__stdcall，例如：

{% highlight c %}
int __stdcall add(int a, int b);
{% endhighlight %}

在delphi中将这个函数也声明为__stdcall，就可以调用了：

{% highlight delphi %}
function add(a: Integer; b: Integer): Integer;
stdcall; external 'a.dll';
{% endhighlight %}
因为考虑到可能被其它语言的程序调用，不少API采用__stdcall的调用约定。
